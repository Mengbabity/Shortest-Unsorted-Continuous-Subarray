# Shortest-Unsorted-Continuous-Subarray

问题：给定一个数组，找出最短的子集，使得该子集如果顺序，则整个数组顺序。

思路：开始的想法是，设一个vector<bool>,当后一个数小于前一个数则该位置为false最后将最远的两个false相减即可得到长度。
     但忽略了这种情况（2，3，3，2，4），我的算法结果为2，但实际为4。即会忽略掉有相同数字的结果。
     
解法：给定两个指针left和right。
     利用while循环，将left置于一个特定数，该数的下一个数大于自己（即非递增序列的开头），同样将right置于一个特定数，该数的前一个数大于自己（不一定是尾端）。
     如果right>left，说明存在非递增序列。
     for循环开始于left，终止于right。将其中最大的值赋给imax,最小的值赋给imin，尽管不确定头和尾，这也是整个非递增序列的最值。
     接下来在while循环中，当left大于等于最小值，left--，最终停在要找的非递增序列的头-1；
     当right小于等于最小值，right++，最终停在非递增序列的尾部。
